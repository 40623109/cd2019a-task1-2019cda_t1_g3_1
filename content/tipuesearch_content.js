var tipuesearch = {"pages": [{'title': '簡介', 'text': '產品協同設計課程第三組 \n', 'tags': '', 'url': '簡介.html'}, {'title': '組員', 'text': '40623105\xa0 \n 40623109 \n 40623112 \n 40623118 \n 40623125 \n 40623127 \n 40623128 \n 40623135 \n 40623141 \n 40623156 \n', 'tags': '', 'url': '組員.html'}, {'title': '手足球', 'text': '圖檔位置: \n https://cad.onshape.com/documents/0bfaa15bd19b1324aaa7e507/w/04eb23a61d6467f8c87c3a8e/e/ecd14e928fc285a5eb479e63 \n 藉由 建立手足球系統來更加熟悉vrep的各項設定與操作 \n', 'tags': '', 'url': '手足球.html'}, {'title': '足球自動回擊', 'text': '\n vrep檔案位置: tablefootball.ttt \n \n python原始碼: \n import vrep\nfrom time import sleep\nimport sys, math\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV = 90      #手把轉速設定(度/秒)\nMove_Minus =-0.1          #手把水平移速(m/s)\nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\n\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef getballposition():\n    errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    vv =position_D[1] - position_P[1]\n    vvv =position_D[2] - position_P[2]\n    while (n == 1):\n        \n        if vv <= 0 and vvv <= 0.01:\n            errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            vv =position_D[1]- position_P[1]\n            vvv =position_D[0] - position_P[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n        \n        elif vv > 0 and vvv <= 0.01:\n            errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            vv =position_D[1]- position_P[1]\n            vvv =position_D[0] - position_P[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\n            \n        elif vv <= 0 and vvv > 0.01:\n            errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            vv =position_D[1]- position_P[1]\n            vvv =position_D[0] - position_P[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\n        \n        elif vv > 0 and vvv > 0.01:\n            errorCode,position_P=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_D=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            vv =position_D[1]- position_P[1]\n            vvv =position_D[0] - position_P[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\n        \n        \n        vrep.simxSetJointTargetVelocity(clientID,BMo_handle,vv,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop()\n\n\n\n\n\n \n ＿ \n', 'tags': '', 'url': '足球自動回擊.html'}, {'title': '手足球雙人對打', 'text': '\n vrep檔案位置: tablefootball.ttt \n python控制程式 \n import vrep\nimport keyboard\nfrom time import sleep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV = 90    \nMove_Minus =-0.1         \nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\n\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef setting():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1]- position_BR[1]\n    BBv =position_S[0] - position_BR[0]\n    Rv =position_S[1]- position_RR[1]\n    RRv =position_RR[0]-position_S[0]\n\ndef getballposition():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1] - position_BR[1]\n    BBv =position_S[2] - position_BR[2]\n    Rv =position_S[1] - position_RR[1]\n    RRv =position_S[2] - position_RR[2]\n    while True:\n        try:\n            if keyboard.is_pressed(\'v\'):\n                vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'b\'):\n                vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'z\'):\n                vrep.simxSetJointTargetVelocity(clientID,BMo_handle,0.05,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'x\'):\n                vrep.simxSetJointTargetVelocity(clientID,BMo_handle,0,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'c\'):\n                vrep.simxSetJointTargetVelocity(clientID,BMo_handle,-0.05,vrep.simx_opmode_oneshot_wait)\n            \n            elif keyboard.is_pressed(\'o\'): \n                vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'p\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'y\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,0.05,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'u\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n            elif keyboard.is_pressed(\'i\'):  \n                vrep.simxSetJointTargetVelocity(clientID,RMo_handle,-0.05,vrep.simx_opmode_oneshot_wait)\n            else:\n                pass\n        except:\n            break \n        MMMB = Bv*2\n        MMMR = Rv*2\n    vrep.simxSetJointTargetVelocity(clientID,BMo_handle,MMMB,vrep.simx_opmode_oneshot_wait)\n    vrep.simxSetJointTargetVelocity(clientID,RMo_handle,MMMR,vrep.simx_opmode_oneshot_wait)\n    \nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop() \n \n', 'tags': '', 'url': '手足球雙人對打.html'}, {'title': '手足球電腦對電腦', 'text': '\n vrep檔案位置: tablefootball.ttt \n \n python控制程式: \n import vrep\nfrom time import sleep\nimport sys, math\n# child threaded script: \n# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入\n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\nKickBallV = 45     #手把轉速設定(度/秒)\nMove_Minus =-0.1          #手把水平移速(m/s)\nMove_Plus =0.1\nn=1\nR_KickBallVel = (math.pi/180)*KickBallV\nB_KickBallVel = -(math.pi/180)*KickBallV\nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Sphere_handle=vrep.simxGetObjectHandle(clientID,\'Sphere\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRod_handle=vrep.simxGetObjectHandle(clientID,\'BRod\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BRev_handle=vrep.simxGetObjectHandle(clientID,\'BRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,BMo_handle=vrep.simxGetObjectHandle(clientID,\'BMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRev_handle=vrep.simxGetObjectHandle(clientID,\'RRev\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RMo_handle=vrep.simxGetObjectHandle(clientID,\'RMo\',vrep.simx_opmode_oneshot_wait)\nerrorCode,RRod_handle=vrep.simxGetObjectHandle(clientID,\'RRod\',vrep.simx_opmode_oneshot_wait)\n\nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n    \ndef stop():\n    errorCode = vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef start():\n    errorCode = vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n    \ndef pause():\n    errorCode = vrep.simxPauseSimulation(clientID,vrep.simx_opmode_oneshot_wait)\n\ndef setting():\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1]- position_BR[1]\n    BBv =position_S[0] - position_BR[0]\n    Rv =position_S[1]- position_RR[1]\n    RRv =position_RR[0]-position_S[0]\n\ndef getballposition():\n    #for i in range(steps):\n    errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n    errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n    Bv =position_S[1] - position_BR[1]\n    BBv =position_S[0] - position_BR[0]\n    Rv =position_S[1] - position_RR[1]\n    RRv =position_S[0] - position_RR[0]\n    while (n == 1):\n        \n        if Bv <= 0 and BBv <= 0.02 and Rv<=0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv <= 0.02 and Rv<=0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv > 0.02 and Rv<=0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv > 0.02 and Rv<=0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv <= 0.02 and Rv>0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv <= 0.02 and Rv>0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv > 0.02 and Rv>0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv > 0.02 and Rv>0 and RRv <= 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv <= 0.02 and Rv<=0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv <= 0.02 and Rv<=0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv > 0.02 and Rv<=0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv > 0.02 and Rv<=0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv <= 0.02 and Rv>0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv <= 0.02 and Rv>0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv <= 0 and BBv > 0.02 and Rv>0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        elif Bv > 0 and BBv > 0.02 and Rv>0 and RRv > 0.02:\n            errorCode,position_BR=vrep.simxGetObjectPosition(clientID,BRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_RR=vrep.simxGetObjectPosition(clientID,RRod_handle,-1,vrep.simx_opmode_oneshot)\n            errorCode,position_S=vrep.simxGetObjectPosition(clientID,Sphere_handle,-1,vrep.simx_opmode_oneshot)\n            Bv =position_S[1]- position_BR[1]\n            BBv =position_S[0] - position_BR[0]\n            Rv =position_S[1]- position_RR[1]\n            RRv =position_RR[0]-position_S[0]\n            vrep.simxSetJointTargetVelocity(clientID,BRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            vrep.simxSetJointTargetVelocity(clientID,RRev_handle,B_KickBallVel,vrep.simx_opmode_oneshot_wait)\n            #print(RRv)\n        else:\n                pass\n        MMMB = Bv*1.2 \n        MMMR = Rv*1.2\n        \n        vrep.simxSetJointTargetVelocity(clientID,BMo_handle,MMMB,vrep.simx_opmode_oneshot_wait)\n        vrep.simxSetJointTargetVelocity(clientID,RMo_handle,MMMR,vrep.simx_opmode_oneshot_wait)\n        #print(BBv)\nvrep.simxSetJointTargetVelocity(clientID,BRev_handle,0,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RRev_handle,R_KickBallVel,vrep.simx_opmode_oneshot_wait)\nvrep.simxSetJointTargetVelocity(clientID,RMo_handle,0,vrep.simx_opmode_oneshot_wait)\n\nstart()\ngetballposition()\nstop() \n \n', 'tags': '', 'url': '手足球電腦對電腦.html'}, {'title': '手足球問題與解決方案', 'text': '手足球問題一 \n 如何知道目前的球的位置? \n 解決方法: \n 運用指令 \n number returnCode,number parentObjectHandle=vrep.simxGetObjectParent(number clientID,number objectHandle,number operationMode) \n 來得到目前座標 \n \n 手足球問題二 \n 如何讓回擊的桿子偵測球的位置進行移動? \n 解決方法: \n 利用指令得到球與桿子的y方向座標之後 \n 利用相減所得到的值可以知道球在桿子的左邊或是右邊 \n \n 手足球問題三 \n 直接給定桿子橫向移動的速度為0.5m/s \n 會讓他產生速度從0瞬間變 0.5m/s 的現象 \n 解決方法: \n 把給定的速度更改為桿子與球座標的差值 \n \n', 'tags': '', 'url': '手足球問題與解決方案.html'}, {'title': '參考資料', 'text': '\n', 'tags': '', 'url': '參考資料.html'}, {'title': '課程內容整理', 'text': '', 'tags': '', 'url': '課程內容整理.html'}, {'title': '隨身系統', 'text': '藉由自行製作隨身系統，來了解隨身系統的運作方式，以便了解工具的使用與設定，並可以量身打造所需的隨身系統。 \n', 'tags': '', 'url': '隨身系統.html'}, {'title': '創建資料夾', 'text': '創建一個放置可攜檔案的資料夾 \n 並在裡面 創建一個data資料夾用來連結y槽 \n', 'tags': '', 'url': '創建資料夾.html'}, {'title': 'SciTE', 'text': '安裝SciTE至data資料夾中 \n 使用windos的 \xa0 full download版本 \n SciTE Download: https://www.scintilla.org/SciTEDownload.html \n 打開SciTE後 \n 開啟設定檔案 \n \n 利用ctrl+f找到code.page並改為下圖所示 \n \n', 'tags': '', 'url': 'SciTE.html'}, {'title': '安裝 python 進可攜系統', 'text': '安裝時選取自訂義安裝 \n \n 勾選所需要的項目 \n \n \n 設定安裝位置 \n \n 利用 HxD 二位元編輯器設定C:\\p37\\Scripts\\pip.exe \n 使用ctrl+f功能尋找c :\\p37並改為y:\\p37 \n 如紅字處 \n \n \n 更改完成後就可以把整個p37資料夾移至data資料夾 \n', 'tags': '', 'url': '安裝 python 進可攜系統.html'}, {'title': 'start.bat', 'text': '利用安裝的SciTE製作start.bat檔案 \n \n', 'tags': '', 'url': 'start.bat.html'}, {'title': 'stop.bat', 'text': '利用安裝的SciTE製作stop.bat檔案 \n \n', 'tags': '', 'url': 'stop.bat.html'}, {'title': 'Kdiff3', 'text': '在製作過程中想要快速了解兩個檔案之間的差異可以使用Kdiff3來快速比對出不一樣的地方。 \n Kdiff3:  http://kdiff3.sourceforge.net/ \n', 'tags': '', 'url': 'Kdiff3.html'}, {'title': 'ungit-1', 'text': '使用圖形化介面讓使用者更加了解目前所在的分支與倉儲狀況 \n', 'tags': '', 'url': 'ungit-1.html'}, {'title': '如何安裝', 'text': '參考連結 http://mde.tw/wcm2019/content/%E5%AF%A6%E7%BF%92%E9%A0%85%E7%9B%AE%E4%BA%8C.html \n 至上方連結處下載 \xa0 nodejs_with_ungit.7z \n 下載完成後解壓縮到隨身系統資料夾的data中 \n 並在start.bat中加入 \n set USERPROFILE=%Disk%:\\home \n set path8=%Disk%:\\nodejs;%Disk%:\\nodejs\\appdata\\roaming\\npm; \n %path8%; \n 如下圖 \n \n \n 之後在中空白的SciTE中輸入 \n ungit --launchBrowser=0 --launchCommand "C:\\PROGRA~2\\Google\\Chrome\\Application\\chrome.exe\xa0 %%U" \n 存檔至Data中並命名為kungit.bat \n', 'tags': '', 'url': '如何安裝.html'}, {'title': 'ungit 手冊', 'text': '1.首先打開隨身碟命令提示字元，進入tmp下的組別資料夾，打 kungit \n \n 2.下圖為 ungit 開啟後的版面 \n \n 3.取得遠端資訊(Fetch from origin)：可以從近端查看想關注之遠端的資訊 \n ◎ origin : 為原本遠端的 github 網址 \n \n ◎取得想關注的遠端資料(add new remote) \n \n (1)Name的地方打上想要的名稱， Url的地方貼上想要的網址 \n \n (2)送出後，再點選想要查看的網址名稱 \n \n (3)以下為點開後的圖面 \n \n 4.子模組 ( submodules)  : 在資料夾內抓取另一個遠端資料夾內容並新增修改 \n \n ◎新增子模組 (add submodules) \n \n (1)取得想新增的子模組 \n \n (2)Name的地方打上想要的名稱， Url的地方貼上想要的網址 \n \n (3)點選上傳子模組(update submodules) \n \n (4)點選想要新增的子模組 \n \n (5)以下為新增的子模組資料 \n \n (6)資料夾內也會顯示新增的資料夾 \n \n 5.分支 : 切換分支及刪除分支 \n \xa0→ 切換分支：點選想要切換的分支即可 \n \xa0→刪除 分支：點選 x 即可刪除 \n (※如要新增分支請看 9) \n \n 6.忽略內容 \n \n → 點擊後顯示的內容 \n \n 以下示範 :\xa0 \n (1)*.a\xa0 →\xa0 將字尾為 .a 的文件都忽略 \n a. 選擇忽略以.txt為結尾的文件 (附檔名可自行選擇) \n \n b. 將 .gitignore 用 scite 開啟 \n \n c. 在 .gitignore 內新增下圖文字 \n \n d. 修改後 .gitignore 會顯示其內容 \n \n e.\xa0.txt的文件已被忽略(如下圖) \n \n (2) !*lib.a\xa0 → 將字尾為 .a 的文件都忽略但 lib.a\xa0 除外 \n a. 以下要示範忽略 .txt 的文件但 456.txt保留 \n  \xa0(附檔名可自行選擇；不忽略檔案也可自行選擇) \n ↓下圖為2個檔案都存在 \n \n b. 在 .gitignore 內新增下圖文字 \n \n c. 檔案以忽略除了456.txt的文件 \n \n 7. Create an empty commit (新增提交) \n 依序下圖步驟操作即可新增提交 \n \n \n \n \n ↓完成後會顯示，如下圖 \n \n 8. Amend previous commit (修改上一個提交) \n \n \n \n ↓完成會顯示，如下圖 \n \n 9.\xa0 Branch (分支)\xa0 \n \xa0◎add Branch (新增分支)\xa0 \n (1) 點下圖中的圖形即可新增分支或標籤 \n \n (2) 打上名稱(此處以新增 branch 為範例) \n \n (3) 會顯示 aaa 分支 \n \n ◎ checkout branch (切換分支) \n 依序下圖進行操作就可以切換分支 \n ↓按下aaa，再點選check out \n \n ↓完成後，即可切換分支 \n \n ◎ delete branch\xa0 (刪除分支) \n \n 刪除此 aaa 分支或標籤，讓其進行還原 \n \n 下圖為還原後顯示的畫面 \n \n 10. add Tag (新增標籤)\xa0 \n 標籤是對某個 commit 的指標，類似於分支，標籤可分兩種： \n ◎輕量標籤 (lightweight tag)：是指對某個 commit 的指標，沒有包含其他附註資訊，用來個人使用或暫時標註。 \n ◎有附註標籤(annotated tag)：類似於輕量標籤，只是能多附註關於此張標籤的說明及資訊，用於軟體版號等。 \n 新增及刪除標籤步驟跟 branch 相同，在此會用圖說明標籤與分支的不同 \n (1) 在\xa0commit\xa0"test tag-1" 上新增\xa0 "說明標籤與分支的不同" 的標籤 \n \n (2) 新增後 \n \n (3) 提交一個 "test tag-2" 的 commit ，分支 aaa 移至新的提交位置上，而標籤 " 說明標籤與分支的不同 " 停留於原處。 \n \n 11. Megre (合併) \n \n \n 12. uncommit (不提交) \n \n 下為按下 uncommit 後的圖面 \n \n 從這開始就有不同的步驟去刪除多餘的提交 \n (1) 用 Move 使其刪除 \n →將藍色origin/master拖曳至move \n \n a. \n \n b. \n \n c. \n \n d.\xa0 \n \n (2) 利用 push 推回 \n \n 按下 push 後也會產生出 a. b. c. d. 圖 \n 13.\xa0 Move (移動) \n 可用來移動分支，範例如下 \n (1) 點分支 master\xa0 \n \n (2) 按下 Move\xa0 \n \n (3) 詢問是否移動此分支(這個行動有在歷史上出現過) \n \n (4) 下為移動後的圖面 \n \n 14. Cherry pick (撿取某分支的 commit 來合併，但不是全部的 commit ) \n (1) 下圖中游標所在位置是想要合併的 commit ，點它 \n \n (2)按下 Cherry pick\xa0 \n \n (3) master所在位置為撿取的 commit\xa0 \n \n \n 15. Revert (還原) \n 再做一個 新 commit ，來取消不要的 commit，原本的 commit 還是會存留在歷史紀錄中。 \n 適合在多人共同協作的專案中，使用 Revert 對於其他協同者來說不算是 修改歷史 ，而是增加一個新的 commit 。 \n (1) 在資料夾中新增 2.txt \n \n (2) 進行 commit and push\xa0 \n \n (3) 點選要進行 revert 的 commit \n \n (4) 點 revert\xa0 \n \n (5) 會顯示出 Rvert "test revert"，此項新 commit\xa0 \n \n (6) 資料夾中的 2.txt 會消失，讓整個資料夾還原 \n \n 16. Reset (重新) \n 直接刪除不要的 commit (會讓歷史中的紀錄改變)，常用在未推交的 commit ，適用於個人的專案。 \n (1) 進行 commit\xa0 \n \n (2) 點游標所在處 \n \n (3) 按 Reset \n \n \n \n 17. Rebase (重新定義參考基準) \n 重新定義某分支的參考基準。每一個 commit 都能增加分支，而分支的基準就是產生出此分支的 commit ，rebase 是能把產生出該分支的 commit 改到另一個 commit ，但是使用 rebase 會影響到 commit 原有的先後關係，所以操作時要多加注意。在此使用範例去解說： \n (1) 利用 scite 建立一個 test rebase.htm ，內容如下圖並另存至資料夾。 \n \n (2) 在分支 master 上進行提交 \n \n (3) 修改先前的 test rebase.htm ，內容如下圖，在分支 master 進行第二次提交。 \n \n (4) 在 test rebase-1的 commit 中增加一個 test 分支。 \n \n (5)\xa0切換至分支 test，在 test rebase-1 的 commit 其所有內容會回至先前的這個 commit 所擁有的內容。 \n \xa0 \n (6) 修改 scite 中的內容，並在分支 test 中提交。 \n \n (7) 在分支 test 執行 rebase \n \n (8) 會讓分支 master 的內容與分支 test 接再一起。 \n \n (9) 最後在資料夾的 test rebase.htm 內容會變成下圖中所展示。 \n \n 18. Squash (提交的合併) \n 讓此 commit 與前一個 commit 合併，(但保留原有的 commit )。 \n (1) 建立 test squash 進行提交 \n \n (2) 再進行第二次提交，提交名稱 test squash-1。 \n \n (3) 執行 squash \n \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'ungit 手冊.html'}, {'title': 'ssh金鑰', 'text': '參考連結: https://2019wcm.blogspot.com/2019/03/github-github-pages.html \n', 'tags': '', 'url': 'ssh金鑰.html'}, {'title': '關閉跳出式登入窗', 'text': '首先 使用 git config --edit --system \n 叫出vi 編輯器,編輯git的設定檔案 \n 使用按鍵H,J,K,L控制上下左右 \n 案a進入編輯模式 \n 編輯模式最底下會顯示 \n -- INSERT -- \n 就可以按BACKSPACE刪除最後一行如下圖 \n \n 刪除後按ESC鍵離開編輯模式 \n 再輸入冒號後，再輸入wq存檔並關閉。 \n 如果要直接離開則輸入exit \n', 'tags': '', 'url': '關閉跳出式登入窗.html'}, {'title': '製作金鑰', 'text': '在 可攜系統的命令列視窗輸入sh或者是sh_yen(可至y:\\git\\bin中確認) \n 執行 Git 的 shell \n 並輸入 \n ssh-keygen -t rsa -b 4096 -C "This is my key" \n 將會建立Private 與 Public 金鑰至y:\\home\\.ssh\\id_rsa與id_rsa.pub \n 將 id_rsa.pub 的內容複製轉貼至Github 帳號的settings如下圖位置 \n \n \n \n 在SSH and GPG keys的SSH Key新建並貼上複製內容 \n', 'tags': '', 'url': '製作金鑰.html'}, {'title': '利用SSH提交推送', 'text': '首先要確認倉儲是以SSH的方式clone的 \n 利用以下指令clone或 \n git clone\xa0 git@github.com:倉儲擁有者/ 倉儲名 \n 或是直接利用SciTE開啟倉儲的.git檔案裡面的config \n 把url = https://github.com/ 倉儲擁有者/ 倉儲名 \n 改成url = git@github.com: 倉儲擁有者/ 倉儲名 \n 之後直接提交推送就可以不用打帳號密碼了 \n', 'tags': '', 'url': '利用SSH提交推送.html'}, {'title': 'git', 'text': '', 'tags': '', 'url': 'git.html'}, {'title': '10.1', 'text': 'Plumbing and Porcelain \n \n \n \n', 'tags': '', 'url': '10.1.html'}, {'title': '10.2', 'text': 'Git Objects \n cat -file 從Git 取回資料 \n update - ref更新引用 \n', 'tags': '', 'url': '10.2.html'}, {'title': '10.3', 'text': 'Git References \n 如何知道最後一次提交？ : \n 執行\xa0 git branch\xa0 \n $ cat .git/HEAD  \n ref: refs/heads/master \n 執行 git checkout test \n $ cat .git/HEAD  \n ref: refs/heads/test \n 手動編輯此文件，但同樣可以執行更安全的命令: \n 執行symbolic-ref \n $ git symbolic-ref HEAD  \n refs/heads/master \n 設置HEAD: \n $ git symbolic-ref HEAD  refs/heads/test  \n $ cat .git/HEAD  \n ref: refs/heads/test \n \n \n \n', 'tags': '', 'url': '10.3.html'}, {'title': '10.4', 'text': 'Packfiles 使用 git cat-file 命令查看這個文件大小 \n $ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 22044 \n 使用git gc打包文件 \n $ git gc Counting objects: 18, done. Delta compression using up to 8 threads. Compressing objects: 100% (14/14), done. Writing objects: 100% (18/18), done. Total 18 (delta 3), reused 0 (delta 0) \n \n', 'tags': '', 'url': '10.4.html'}, {'title': '10.5', 'text': 'The Refspec \n .git / config文件中添加遠端origin的名稱，遠程存儲庫的URL以及用於獲取的refspec \n [remote "origin"] url = https://github.com/schacon/simplegit-progit fetch = +refs/heads/ :refs/remotes/origin/ 如果想一次性執行某些操作，也可以在命令行中指定refspec \n $ git fetch origin master:refs/remotes/origin/mymaster 指定多個refspec \n $ git fetch origin master:refs/remotes/origin/mymaster \\\n\t topic:refs/remotes/origin/topic\nFrom git@github.com:schacon/simplegit\n ! [rejected]        master     -> origin/mymaster  (non fast forward)\n * [new branch]      topic      -> origin/topic 刪除 refspec git push origin :topic git push origin -- delete topic \n', 'tags': '', 'url': '10.5.html'}, {'title': '10.6', 'text': 'Transfer Protocols \n Transfer Protocols--傳輸協議 \n Git可以透過兩種主要方式在兩個倉儲之間傳輸數據：“啞吧”協議與“智能”協議。 本章重點著重於介紹這兩個主要協議的運作方式。 \n The Dumb Protocol--啞巴協議 \n 該協議稱為“啞巴協議”，是因為它在傳輸過程中不需要服務端的Git特定代碼;\xa0獲取過程是一系列HTTP\xa0 GET 請求，使用者可以自由的呈現Git倉儲的安排。 \n', 'tags': '', 'url': '10.6.html'}, {'title': '10.7', 'text': 'Transfer Protocols \n 本章重點在介紹Git內部的維護和數據的恢復，有時Git會自動執行一個名為“auto\xa0 gc ”的指令，大多數情況下，指令不執行操作，但如果有過多的packfiles，則Git會執行git gc的指令，此指令會刪除不必要的文件。 \n 當需要恢復檔案時 可使用git long和git master兩個指令來進行恢復。 \n', 'tags': '', 'url': '10.7.html'}, {'title': '10.8', 'text': 'Environment Variables \n Git在 bash shell中運行，並使用許多shell環境變量來確定它的行為方式。 \n GIT_EXEC_PATH： 可透過運行檢查當前設置 git --exec-path 。 \n HOME： 它是Git查找全局配置文件的地方。 \n GIT_CONFIG_NOSYSTEM： 如果您的系統配置干擾了您的指令，但是您無權更改或刪除它，這將非常有用。 \n 設置提交者的名字:\xa0 GIT_COMMITTER_NAME \n \n “提交者”字段的電子郵件地址:\xa0 GIT_COMMITTER_EMAIL \xa0 \n \n \n \n 用於“提交者”字段中的日期:\xa0 GIT_COMMITTER_DATE \n \n \n', 'tags': '', 'url': '10.8.html'}, {'title': '10.9', 'text': 'Summary \n 功能很強的系統工具-Git \n 可以輕鬆使用它作為VCS。本章介紹了許多管道指令 - 這些指令使用戶在使用上更家簡單。 \n \n', 'tags': '', 'url': '10.9.html'}, {'title': 'V-rep', 'text': '', 'tags': '', 'url': 'V-rep.html'}, {'title': 'Proximity sensor', 'text': '添加 接近傳感 器\xa0 proximity sensor \n Menu bar --> Add --> Proximity sensor --> Cone type \n \n 在\xa0 orientation dialog \xa0對話框中 \n 沿y軸和z軸旋轉90度\xa0 \xa0點擊Rotation Selection \n \n 在\xa0 position dialog \xa0對話框中 \n x方向設置0.1\xa0 z方向設置0.12 \n \n 修改距離傳感器的參數Show volume parameter \n Offset \xa0 \xa00.005, \xa0 Angle \xa0 \xa030  \xa0 Range \xa0 \xa00.15 \n Show detection parameter中將Don’t\xa0 allow detection ifdistance smaller than取消 \n 最後將傳感器連接到機器人的身體 \n \n', 'tags': '', 'url': 'Proximity sensor.html'}, {'title': 'Vision sensor', 'text': '添加視覺傳感器\xa0 vision sensor \n Menu bar-->Add-->Vision sensor-->Perspective type \n 將視覺傳感器和距離傳感器放置一起且方向一致 \n 1. 在視覺傳感器的屬性欄中配置Far clipping plane 爲1 \n \xa0 \xa0 Resolution x 和y 設爲256和256 \n 2. 點擊show filter dialog\xa0 \n \n 3. 選擇Edget detection on work image \n \xa0 \xa0然後點擊Add filter \n 4. 閾值設置爲0.2 點選OK \n \n Floating view上右鍵 View-->Associate simulation with selected vision sensor \n \n 就可以看到視覺感測器的畫面 \n \n', 'tags': '', 'url': 'Vision sensor.html'}, {'title': 'bubbleRob腳本', 'text': '選擇對象BubbleRob--->右鍵選擇Add-->Associate child script-->Non threaded \n 腳本文件語言爲lua語言 \n function speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) -- this is bubbleRob\'s handle\n    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") -- Handle of the left motor\n    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") -- Handle of the right motor\n    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") -- Handle of the proximity sensor\n    minMaxSpeed={50*math.pi/180,300*math.pi/180} -- Min and max speeds for each motor\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.create(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor) -- Read the proximity sensor\n    -- If we detected something, we set the backward mode:\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end \n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,speed)\n        sim.setJointTargetVelocity(rightMotor,speed)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui)\nend \n \n', 'tags': '', 'url': 'bubbleRob腳本.html'}, {'title': 'bubbleRob', 'text': '成品圖 \n \n \n \n \n \n', 'tags': '', 'url': 'bubbleRob.html'}, {'title': '問題與討論', 'text': '', 'tags': '', 'url': '問題與討論.html'}, {'title': 'ungit-2', 'text': '', 'tags': '', 'url': 'ungit-2.html'}, {'title': '問題-無法取得使用者資料-已解決', 'text': '當使用ungit提交推送時，出現如下圖的錯誤內容 \n \n 解決方法: \n 至啟動隨身系統的start.bat中加入 \n set USERPROFILE=%Disk%:\\home \n 使ungit能找到 y:\\home中的使用者目錄 \n', 'tags': '', 'url': '問題-無法取得使用者資料-已解決.html'}, {'title': '組員操作影片', 'text': '', 'tags': '', 'url': '組員操作影片.html'}, {'title': '如何製作可攜系統', 'text': '40623105 \n \n 40623109 \n \n 40623118 \n \n 40623141 \n \n 40623156 \n \n', 'tags': '', 'url': '如何製作可攜系統.html'}, {'title': 'Git教材', 'text': '', 'tags': '', 'url': 'Git教材.html'}, {'title': '伺服器上的Git', 'text': 'Git可以使用四種主要協議來傳輸數據： \n Local protocols、HTTP、Secure Shell（SSH）和Git。 \n 通過上方多種方式啟動並運行遠程Git存儲庫，以便您可以與其他人協作或共享您的工作。 \n 運行自己的服務器可以為您提供很多控制，並允許您在自己的防火牆內運行服務器，但是這樣的服務器通常需要相當多的時間來設置和維護。 \n', 'tags': '', 'url': '伺服器上的Git.html'}, {'title': '通訊協定種類', 'text': '\n Local protocols \n 優點: \n 1.可以直接將存儲庫副本粘貼到每個人都具有共享存取權限的位置，並像設置任何其他共享目錄一樣設置讀/寫權限。 \n 2.運用這些指令(git pull /home/john/project等) ，通常會更簡單地使他們推送到遠端，並且您也方便拉取。 缺點: \n 1.共享存取通常更難以從多個位置進行設置和存取。 \n 2.若在家使用筆電的話，需額外安裝遠端系統，否則會相對於基本網路存取還要來得困難與慢上許多。 \n 3.每個用戶都具有對“遠程”目錄的完全要訪問權限，並且沒有任何東西阻止他們更改或刪除內部Git文件並破壞存儲庫。 \n SSH通訊協定( Secure Shell ) \n 優點: \n 1.SSH相對容易設置，且它的守護程序很常見。 \n 2.透過SSH存取是安全的，所有數據傳輸都經過加密和身份驗證。 \n 3.像HTTP/S、Git與Local protocols一樣，使數據在傳輸之前盡可能緊湊。 \n 缺點: \n 1.無法通過它對存儲庫進行匿名存取。 \n 2.如果想允許匿名存取項目並且還想使用SSH，則必須設置SSH以便推送，但其他內容可供其他人獲取。 \n Git協定 \n 優點: \n 1.為最快的網絡傳輸協議。 \n 2.若為公共項目提供大量流量或為不需要用戶身份驗證進行讀取的大型項，則可能需要設置Git守護程序。 \n 3.Git存儲庫可供所有人克隆。 \n 缺點: \n 1.缺乏身份驗證。 \n 2.通常為唯一存取權限(即推送、寫入等)，若開啟推送存取權限，則網路上能到找到項目的URL並任何人可推送到項目裡。 \n HTTP \n 可分為兩種，分別為新制(智能)與舊制。 \n 新制(智能): \n 與SSH或Git協定的運行方式非常相似，它可以設置為像git://協議一樣匿名服務，也可以通過SSH協議等身份驗證和加密來推送。 \n 舊制: \n 直接將Git存儲庫提供為來自Web服務器的普通文件，優點在於設置它的簡單性。此外，任何可以訪問放置存儲庫的Web服務器的人都可以存取您的存儲庫。 \n 以下優缺點於新制(智能)HTTP \n 優點: \n 1.能夠使用用戶名和密碼進行身份驗證。 \n 2.通過HTTPS以只讀方式提供存儲庫。 \n 缺點: \n 與某些服務器上的SSH相比，在HTTP/S上使用Git可能會有點棘手。 \n \n \n \n \n', 'tags': '', 'url': '通訊協定種類.html'}, {'title': '在伺服器上佈署Git', 'text': '要clone存儲庫以創建新的存儲庫，請使用該--bare選項運行clone命令。將存儲庫目錄結束.git。如下: \n $ git clone --bare my_project my_project.git \n 現在應該在目錄中擁有Git目錄數據的副本my_project.git。 \n 下面指令相當於類似的東西，但配置文件中存在一些細微差別。 \n $ cp -Rf my_project/.git my_project.git \n 將存儲庫複製到以下來設置新存儲庫： \n 假設/srv/git存在於該服務器上，並且已經設置了一個名為git.example.com的SSH服務器，而希望將所有Git存儲庫存儲在該/srv/git目錄下。 \n $ scp -r my_project.git user@git.example.com:/srv/git \n 之後，對於有這目錄及SSH的權限的用戶就可以來clone，也有推送訪問權限。 \n $ git clone user@git.example.com:/srv/git/my_project.git \n 如果git init使用該--shared選項運行命令，Git將自動將組寫入權限正確添加到存儲庫。 \n $ ssh user@git.example.com $ cd /srv/git/my_project.git $ git init --bare --shared \n \n', 'tags': '', 'url': '在伺服器上佈署Git.html'}, {'title': '產生個人的SSH公鑰', 'text': '在該目錄並列出內容來輕鬆檢查是否已有密鑰。 輸入指令後有出現文件為id_dsa(id_rsa)為自己私人的密鑰，而文件後方多了.pub則為公鑰。如下: ~/.ssh為目錄 \n $ cd ~/.ssh \n $ ls \n authorized_keys2 \n id_dsa \n known_hosts \n config \n id_dsa.pub \n 如沒有密鑰時，可輸入下列指令來創建。 \n $ ssh-keygen \n 之後，會需要確保密鑰（.ssh/id_rsa）的位置，需輸入兩次密碼，不需要則可空白。 \n 如用戶需要複製有公鑰文件的內容，輸入下列指令。 ~/.ssh/id_rsa為公鑰位置 \n $ cat ~/.ssh/id_rsa.pub \n', 'tags': '', 'url': '產生個人的SSH公鑰.html'}, {'title': '伺服器的設定', 'text': '如要設置SSH存取的服務端，則需使用下列方式來進行身分驗證。 \n **git為用戶名、 .ssh為目錄、authorized_keys為驗證** \n $ sudo adduser git \n $ su git \n $ cd \n $ mkdir .ssh && chmod 700 .ssh \n $ touch .ssh/authorized_keys && chmod 600 .ssh/authorized_keys \n 如需要為該用戶的文件添加一些開發人員的SSH公鑰，並將其保存到臨時文件中。如下: \n **john為開發人員的SSH公鑰** \n $ cat /tmp/id_rsa.john.pub \n 在一個沒有工作目錄的情況下設置一個空儲存庫。 \n $ cd /opt/git \n $ mkdir project.git \n $ cd project.git \n $ git init --bare \n 將文件推送至遠端儲存庫。 \n **myproject為文件** \n', 'tags': '', 'url': '伺服器的設定.html'}, {'title': 'Git常駐程式', 'text': '如不想將大量的項目或人員都添加SSH密鑰時，以守護進程的方式運行下列指令: 此方法雖然設置方便而快速，但因沒有密鑰的身分驗證，所以任何人都可以存取裡面的內容。多用於世界性的公開項目。 \n $ git daemon --reuseaddr --base-path=/opt/git/ /opt/git/ \n --reuseaddr是允許服務器重新啟動而無需等待舊連接超時 \n --base-path是允許人們克隆項目而不指定整個路徑 \n **最後的路徑需告訴Git守護程序在哪裡查找要導出的存儲庫** \n 如果你正在運行防火牆，你還需要在你正在設置它的盒子上的端口9418處打一個洞。 但建議將此守護程序作為具有存儲庫的唯讀權限的用戶運行。 \n 在Ubuntu計算機上，您可以使用Upstart的腳本，並在文件中放入腳本。 \n **文件為/etc/init/local-git-daemon.conf** \n 腳本: \n start on startup \n stop on shutdown \n exec /usr/bin/git daemon \\ \n --user=git --group=git \\ \n --reuseaddr \\ \n --base-path=/opt/git/ \\ \n /opt/git/ \n respawn \n 要在不重新啟動的情況下運行計算機時 \n $ initctl start local-git-daemon \n 允許未經身份驗證的用戶存取指定的儲存庫。 \n $ cd /path/to/project.git \n $ touch git-daemon-export-ok \n \n', 'tags': '', 'url': 'Git常駐程式.html'}]};